# Transactions

### Транзакция — упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое.

#### A - atomicity 
#### C - consistency
#### I - isolation
#### D - durability

## Java

Connection connection = dataSource.getConnection();

try (connection) { 
connection.setAutoCommit(false);
// выполнить несколько SQL-запросов...
connection.commit();

} catch (SQLException e) {
connection.rollback();
}

когда вы используете @Transactional над бинами, Spring использует маленькую хитрость. Он не просто инстанцирует UserService, но и транзакционный прокси этого UserService.

Ваш UserService проксируется на лету, и прокси управляет транзакциями для вас. Но не сам прокси управляет всем этим транзакционным состоянием (открыть, зафиксировать, закрыть), прокси делегирует эту работу менеджеру транзакций.
Spring предлагает вам интерфейс PlatformTransactionManager / TransactionManager, который по умолчанию поставляется с парой удобных реализаций. Одна из них - менеджер транзакций источника данных.

Подведем итоги:
Если Spring обнаруживает аннотацию @Transactional на бины, он создаёт динамический прокси этого бины.
Прокси имеет доступ к менеджеру транзакций и будет просить его открывать и закрывать транзакции/соединения.
Сам менеджер транзакций Управляen старым добрым соединением JDBC.

Изменение режима распространения (propagation) на requires_new говорит Spring, что метод должен выполняться в собственной транзакции, независимо от любой другой, уже существующей транзакции.
@Transactional(propagation = Propagation.REQUIRES_NEW)

Физические транзакции: это ваши фактические транзакции JDBC.
Логические транзакции: это (потенциально вложенные) аннотированные @Transactional методы Spring.

propagation:
Required (по умолчанию): Моему методу нужна транзакция, либо откройте ее для меня, либо используйте существующую → getConnection().setAutocommit(false).commit()
Supports: Мне не важно, открыта транзакция или нет, я могу работать в любом случае → не имеет отношения к JDBC
Mandatory: Я не собираюсь открывать транзакцию сам, но я буду плакать, если никто другой не откроет её → не имеет отношения к JDBC
Require_new: Я хочу полностью собственную транзакцию → getConnection().setAutocommit(false).commit()
Not_Supported: Мне очень не нравятся транзакции, я даже попытаюсь приостановить текущую, запущенную транзакцию → ничего общего с JDBC
Never: Я буду плакать, если кто-то другой запустит транзакцию → не имеет отношения к JDBC
Nested: Это звучит так сложно, но мы просто говорим о точках сохранения! → connection.setSavepoint()

@Transactional(isolation = Isolation.REPEATABLE_READ)
Да, это просто приводит к этому:
connection .setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);

Самый распространенный "подводный камень" @Transactional
Есть один подводный камень, на который обычно наталкиваются начинающие разработчики Spring. Взгляните на следующий код:
@Service
public class UserService {

    @Transactional
    public void invoice() {
        createPdf();
        // отправка счета по электронной почте и т.д.
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
У вас есть класс UserService с транзакционным методом invoice(). Который вызывает createPDF(), который также является транзакционным.
Сколько физических транзакций, по вашему мнению, будет открыто, когда кто-то вызовет invoice()?
Нет, ответ будет не два, а один. Почему?
Давайте вернемся к разделу "Прокси" этого руководства. Spring создает для вас транзакционный прокси UserService, но как только вы оказываетесь внутри класса UserService и вызываете другие внутренние методы, прокси больше не задействован. Это означает, что новой транзакции не будет.

Самым главным выводом должно быть то, что в конечном итоге не имеет значения, какой фреймворк вы используете, все дело в основах JDBC.

Поймите их правильно (помните: getConnection().setAutocommit(false).commit()) и вам будет гораздо легче понять, что произойдет позже в вашем сложном корпоративном приложении.

# Сурсы:
1. struchkov.dev/blog/ru/transaction-jdbc-and-spring-boot/
2. struchkov.dev/blog/ru/transactional-isolation-levels/
